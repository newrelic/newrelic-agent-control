use std::fs::Permissions;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use crate::config::agent_type::agent_types::{FinalAgent, VariableType};
use crate::config::agent_type::trivial_value::TrivialValue;
use crate::config::persister::config_persister::{ConfigurationPersister, PersistError};
use crate::config::super_agent_configs::AgentID;
use crate::fs::directory_manager::{
    DirectoryManagementError, DirectoryManager, DirectoryManagerFs,
};
use crate::fs::writer_file::WriteError;
#[cfg_attr(test, mockall_double::double)]
use crate::fs::writer_file::WriterFile;
use crate::super_agent::defaults::{GENERATED_FOLDER_NAME, SUPER_AGENT_DATA_DIR};

#[cfg(target_family = "unix")]
pub(crate) const FILE_PERMISSIONS: u32 = 0o600;
#[cfg(target_family = "unix")]
const DIRECTORY_PERMISSIONS: u32 = 0o700;

pub struct ConfigurationPersisterFile<C = DirectoryManagerFs>
where
    C: DirectoryManager,
{
    file_writer: WriterFile,
    directory_manager: C,
    generated_conf_path: PathBuf,
}

impl ConfigurationPersisterFile<DirectoryManagerFs> {
    // PersisterFile with defaults writer and directory manager
    // and custom data_dir path
    pub fn new(data_dir: &Path) -> Self {
        let mut generated_conf_dir = PathBuf::from(data_dir);
        generated_conf_dir.push(GENERATED_FOLDER_NAME);

        ConfigurationPersisterFile {
            file_writer: WriterFile::default(),
            directory_manager: DirectoryManagerFs::default(),
            generated_conf_path: generated_conf_dir,
        }
    }
}

impl Default for ConfigurationPersisterFile<DirectoryManagerFs> {
    // default uses the default SUPER_AGENT_DATA_DIR to persist the corresponding files
    fn default() -> Self {
        ConfigurationPersisterFile::new(Path::new(SUPER_AGENT_DATA_DIR))
    }
}

impl<C> ConfigurationPersister for ConfigurationPersisterFile<C>
where
    C: DirectoryManager,
{
    fn persist_agent_config(
        &self,
        agent_id: &AgentID,
        agent_type: &FinalAgent,
    ) -> Result<(), PersistError> {
        // Ensure the autogenerated path exists
        self.directory_manager.create(
            Path::new(&self.generated_conf_path),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        )?;

        // Create path for agent
        let dest_path = self.autogenerated_path(agent_id);
        self.directory_manager.delete(dest_path.as_path())?;
        self.create_directory(dest_path.as_path())?;

        // iterate all fields in agent type and persist file ones
        let writing_result: Result<(), WriteError> = agent_type
            .get_variables()
            .iter()
            .try_for_each(|(_fqn, end_spec)| {
                self.write_file_values_to_file(
                    dest_path.as_path(),
                    &end_spec.kind.variable_type(),
                    &end_spec.kind.get_final_value(),
                )
            });

        Ok(writing_result?)
    }

    fn delete_agent_config(
        &self,
        agent_id: &AgentID,
        _agent_type: &FinalAgent,
    ) -> Result<(), PersistError> {
        let dest_path = self.autogenerated_path(agent_id);
        Ok(self.directory_manager.delete(dest_path.as_path())?)
    }

    fn delete_all_configs(&self) -> Result<(), PersistError> {
        let dest_path = Path::new(&self.generated_conf_path);
        Ok(self.directory_manager.delete(dest_path)?)
    }
}

impl<C> ConfigurationPersisterFile<C>
where
    C: DirectoryManager,
{
    // return the full path for autogenerated data for an Agent
    pub(crate) fn autogenerated_path(&self, agent_id: &AgentID) -> PathBuf {
        let mut path = PathBuf::from(&self.generated_conf_path);
        path.push(agent_id);
        path
    }

    // Write Agent Values Files to files
    // if variable type is File             -> persist to file
    // if variable type is MapStringFile    -> iterate all elements and persist to files
    // any writing error will stop execution and propagate the error
    fn write_file_values_to_file(
        &self,
        dest_path: &Path,
        variable_type: &VariableType,
        final_value: &Option<TrivialValue>,
    ) -> Result<(), WriteError> {
        match (&variable_type, &final_value) {
            (VariableType::File, Some(TrivialValue::File(file_path_with_content))) => {
                // append file name to destination path and write the contents
                let mut file_dest_path = PathBuf::from(dest_path);
                file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                self.write(
                    file_dest_path.as_path(),
                    file_path_with_content.content.as_str(),
                )
            }
            (VariableType::MapStringFile, Some(TrivialValue::MapStringFile(files))) => {
                // iterate all the files inside the map, append them the folder name, append them the file name
                files
                    .iter()
                    .try_for_each(|(filename, file_path_with_content)| {
                        let mut file_dest_path = PathBuf::from(dest_path);
                        file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                        if !file_dest_path.exists() {
                            self.create_directory(file_dest_path.as_path())?;
                        }
                        file_dest_path.push(filename);
                        self.write(
                            file_dest_path.as_path(),
                            file_path_with_content.content.as_str(),
                        )?;

                        Ok(())
                    })
            }
            _ => Ok(()), // Not a file
        }
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        self.file_writer.write(
            path,
            content.to_string(),
            Permissions::from_mode(FILE_PERMISSIONS),
        )
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn create_directory(&self, path: &Path) -> Result<(), DirectoryManagementError> {
        self.directory_manager
            .create(path, Permissions::from_mode(DIRECTORY_PERMISSIONS))
    }

    #[cfg(target_family = "windows")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        todo!()
    }

    #[cfg(target_family = "windows")]
    fn create_directory(&self, path: &Path) -> Result<(), WriteError> {
        todo!()
    }
}

////////////////////////////////////////////////////////////////////////////////////
// TESTS
////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod test {
    use crate::config::agent_values::AgentValues;
    use crate::config::persister::config_persister::ConfigurationPersister;
    use crate::config::persister::config_persister_file::{
        ConfigurationPersisterFile, DIRECTORY_PERMISSIONS, FILE_PERMISSIONS, GENERATED_FOLDER_NAME,
    };
    use crate::config::super_agent_configs::AgentID;
    use crate::fs::directory_manager::test::MockDirectoryManagerMock;
    use crate::fs::directory_manager::DirectoryManager;
    use crate::fs::writer_file::MockWriterFile;
    use std::fs::Permissions;
    use std::io::ErrorKind;
    use std::path::{Path, PathBuf};

    use crate::config::agent_type::agent_types::FinalAgent;
    use crate::fs::directory_manager::DirectoryManagementError::{
        ErrorCreatingDirectory, ErrorDeletingDirectory,
    };
    #[cfg(target_family = "unix")]
    use std::os::unix::fs::PermissionsExt;

    impl<C> ConfigurationPersisterFile<C>
    where
        C: DirectoryManager,
    {
        pub fn with_mocks(
            file_writer: MockWriterFile,
            directory_manager: C,
            generated_conf_path: &Path,
        ) -> Self {
            ConfigurationPersisterFile {
                file_writer,
                directory_manager,
                generated_conf_path: PathBuf::from(generated_conf_path),
            }
        }
    }

    #[test]
    fn test_persist_multiple_single_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_FILES.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_FILES.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config1_path = agent_files_path.clone();
        config1_path.push("newrelic-infra-1.yml");
        file_writer.should_write(
            config1_path.as_path(),
            "license_key: 11111111111111111\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config2_path = agent_files_path.clone();
        config2_path.push("newrelic-infra-2.yml");
        file_writer.should_write(
            config2_path.as_path(),
            "license_key: 22222222222222222\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config3_path = agent_files_path.clone();
        config3_path.push("newrelic-infra-3.yml");
        file_writer.should_write(
            config3_path.as_path(),
            "license_key: 33333333333333333\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &agent_type)
            .is_ok());
    }

    #[test]
    fn test_persist_multiple_single_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_kafka_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_mysql_path = agent_files_path.clone();
        config_mysql_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_mysql_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_mysql_path.push("mysql.yml");
        file_writer.should_write(
            config_mysql_path.as_path(),
            "mysql: true\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_redis_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &agent_type)
            .is_ok());
    }

    #[test]
    fn test_persist_multiple_multiple_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_redis_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_kafka_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_file_path = agent_files_path.clone();
        config_logging_file_path.push("logging.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_logging_file_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_logging_file_path.push("file");
        file_writer.should_write(
            config_logging_file_path.as_path(),
            "some logging conf\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_systemctl_path = agent_files_path.clone();
        config_logging_systemctl_path.push("logging.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_logging_systemctl_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_logging_systemctl_path.push("systemctl.yml");
        file_writer.should_write(
            config_logging_systemctl_path.as_path(),
            "systemctl: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &agent_type)
            .is_ok());
    }

    #[test]
    fn test_error_deleting_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_not_delete(
            agent_files_path.as_path(),
            ErrorDeletingDirectory("oh now...".to_string()),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let result = persister.persist_agent_config(&agent_id, &agent_type);
        assert!(result.is_err());
        assert_eq!(
            "directory error: `cannot delete directory: `oh now...``".to_string(),
            result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_error_creating_agent_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_not_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
            ErrorCreatingDirectory(
                agent_files_path.as_path().to_str().unwrap().to_string(),
                "oh now...".to_string(),
            ),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &agent_type);
        assert!(persist_result.is_err());
        assert_eq!(
            "directory error: `cannot create directory `some/path/SomeAgentID` : `oh now...``"
                .to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_error_creating_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_not_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
            ErrorCreatingDirectory(
                agent_files_path.as_path().to_str().unwrap().to_string(),
                "oh now...".to_string(),
            ),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &agent_type);
        assert!(persist_result.is_err());
        assert_eq!(
            "directory error: `cannot create directory `some/path/SomeAgentID` : `oh now...``"
                .to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_file_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_FILES.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_FILES.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes gill happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::PermissionDenied);

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &agent_type);
        assert!(persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `permission denied``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_filemap_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockWriterFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID").unwrap();
        let mut agent_type: FinalAgent =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: AgentValues =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // populate agent type
        agent_type = agent_type.template_with(agent_values, None).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        let mut integrations_path = agent_files_path.clone();
        integrations_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            integrations_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        let mut integrations_path = agent_files_path.clone();
        integrations_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            integrations_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes will happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::AlreadyExists);

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id.clone(), &agent_type);
        assert!(persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `entity already exists``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_persister_with_custom_data_dir() {
        let custom_data_dir = PathBuf::from("some/data/dir");
        let agent_id = AgentID::new("some_agent_id").unwrap();
        let persister = ConfigurationPersisterFile::new(custom_data_dir.as_path());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = PathBuf::from(custom_data_dir);
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id);

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    #[test]
    fn test_persister_with_custom_data_dir_disallow_dots() {
        let custom_data_dir = PathBuf::from("some/../../data/dir");
        let agent_id = AgentID::new("some_agent_id").unwrap();
        let persister = ConfigurationPersisterFile::new(custom_data_dir.as_path());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = PathBuf::from(custom_data_dir);
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id);

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    //////////////////////////////////////////////////
    // Fixtures
    //////////////////////////////////////////////////

    const AGENT_TYPE_SINGLE_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra.yml
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_FILE: &str = r#"
config_file: |
  license_key: 1234567890987654321
  log:
    level: debug
"#;

    const AGENT_TYPE_MULTIPLE_FILES: &str = r#"

namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file1:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-1.yml
  config_file2:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-2.yml
  config_file3:
    description: "Newrelic infra configuration path"
    type: file
    required: false
    file_path: newrelic-infra-3.yml
    default: |
      license_key: 33333333333333333
      log:
        level: trace
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file1} --config=${config_file2} --config=${config_file3}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_FILES: &str = r#"
config_file1: |
  license_key: 11111111111111111
  log:
    level: info

config_file2: |
  license_key: 22222222222222222
  log:
    level: debug
"#;

    const AGENT_TYPE_SINGLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  mysql.yml: |
    mysql: true
    log:
      level: trace
  kafka.yml: |
    kafka: true
    log:
      level: debug
"#;

    const AGENT_TYPE_MULTIPLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
  logging:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: logging.d
  config3:
    description: "some config map"
    type: map[string]string
    required: true
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations} --logging=${logging}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  kafka.yml: |
    kafka: true
    log:
      level: debug
logging:
  file: |
    some logging conf
  systemctl.yml: |
    systemctl: true
    log:
      level: debug
config3:
  log_level: trace
  forward: "true"
"#;
}
