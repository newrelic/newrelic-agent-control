use std::collections::HashMap;
use std::fs::Permissions;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use crate::agent_type::variable::definition::VariableDefinition;
use crate::agent_type::variable::kind::Kind;
use crate::super_agent::config::AgentID;
use crate::super_agent::defaults::{GENERATED_FOLDER_NAME, SUPER_AGENT_DATA_DIR};
use fs::directory_manager::{DirectoryManagementError, DirectoryManager, DirectoryManagerFs};
use fs::writer_file::{FileWriter, WriteError};
use fs::LocalFile;

use super::config_persister::{ConfigurationPersister, PersistError};

#[cfg(target_family = "unix")]
pub(crate) const FILE_PERMISSIONS: u32 = 0o600;
#[cfg(target_family = "unix")]
const DIRECTORY_PERMISSIONS: u32 = 0o700;

pub struct ConfigurationPersisterFile<W = LocalFile, C = DirectoryManagerFs>
where
    C: DirectoryManager,
    W: FileWriter,
{
    file_writer: W,
    directory_manager: C,
    generated_conf_path: PathBuf,
}

impl ConfigurationPersisterFile<LocalFile, DirectoryManagerFs> {
    // PersisterFile with defaults writer and directory manager
    // and custom data_dir path
    pub fn new(data_dir: &Path) -> Self {
        let mut generated_conf_dir = PathBuf::from(data_dir);
        generated_conf_dir.push(GENERATED_FOLDER_NAME);

        ConfigurationPersisterFile {
            file_writer: LocalFile,
            directory_manager: DirectoryManagerFs::default(),
            generated_conf_path: generated_conf_dir,
        }
    }
}

impl Default for ConfigurationPersisterFile<LocalFile, DirectoryManagerFs> {
    // default uses the default SUPER_AGENT_DATA_DIR to persist the corresponding files
    fn default() -> Self {
        ConfigurationPersisterFile::new(Path::new(SUPER_AGENT_DATA_DIR))
    }
}

impl<W, C> ConfigurationPersister for ConfigurationPersisterFile<W, C>
where
    C: DirectoryManager,
    W: FileWriter,
{
    fn persist_agent_config(
        &self,
        agent_id: &AgentID,
        variables: &HashMap<String, VariableDefinition>,
    ) -> Result<(), PersistError> {
        // Ensure the autogenerated path exists
        self.directory_manager.create(
            Path::new(&self.generated_conf_path),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        )?;

        // Create path for agent
        let dest_path = self.autogenerated_path(agent_id);
        self.directory_manager.delete(dest_path.as_path())?;
        self.create_directory(dest_path.as_path())?;

        // iterate all fields in agent type and persist file ones
        let writing_result: Result<(), WriteError> =
            variables.iter().try_for_each(|(_fqn, end_spec)| {
                self.write_file_values_to_file(dest_path.as_path(), end_spec)
            });

        Ok(writing_result?)
    }

    fn delete_agent_config(&self, agent_id: &AgentID) -> Result<(), PersistError> {
        let dest_path = self.autogenerated_path(agent_id);
        Ok(self.directory_manager.delete(dest_path.as_path())?)
    }
}

impl<W, C> ConfigurationPersisterFile<W, C>
where
    C: DirectoryManager,
    W: FileWriter,
{
    // return the full path for autogenerated data for an Agent
    pub(crate) fn autogenerated_path(&self, agent_id: &AgentID) -> PathBuf {
        let mut path = PathBuf::from(&self.generated_conf_path);
        path.push(agent_id);
        path
    }

    // Write Agent Values Files to files
    // if variable type is File             -> persist to file
    // if variable type is MapStringFile    -> iterate all elements and persist to files
    // any writing error will stop execution and propagate the error
    fn write_file_values_to_file(
        &self,
        dest_path: &Path,
        end_spec: &VariableDefinition,
    ) -> Result<(), WriteError> {
        match end_spec.kind() {
            Kind::File(_) => {
                // retrieve the file path and content
                let file_path_with_content = end_spec
                    .get_final_value()
                    .and_then(|t| t.as_file().cloned())
                    .expect("A file must be present at this point");
                // append file name to destination path and write the contents
                let contents = file_path_with_content.content.as_str();
                let mut file_dest_path = PathBuf::from(dest_path);
                file_dest_path.push(file_path_with_content.path.as_path());
                self.write(file_dest_path.as_path(), contents) // This into() retrieves the contents
            }
            Kind::MapStringFile(_) => {
                let files = end_spec
                    .get_final_value()
                    .and_then(|t| t.as_map_string_file().cloned())
                    .expect("A map of files must be present at this point")
                    .to_owned();
                // iterate all the files inside the map, append them the folder name, append them the file name
                files
                    .iter()
                    .try_for_each(|(filename, file_path_with_content)| {
                        let mut file_dest_path = PathBuf::from(dest_path);
                        file_dest_path.push(&file_path_with_content.path);
                        if !file_dest_path.exists() {
                            self.create_directory(file_dest_path.as_path())?;
                        }
                        file_dest_path.push(filename);
                        self.write(
                            file_dest_path.as_path(),
                            file_path_with_content.content.as_str(),
                        )?;

                        Ok(())
                    })
            }
            _ => Ok(()), // Not a file
        }
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        self.file_writer.write(
            path,
            content.to_string(),
            Permissions::from_mode(FILE_PERMISSIONS),
        )
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn create_directory(&self, path: &Path) -> Result<(), DirectoryManagementError> {
        self.directory_manager
            .create(path, Permissions::from_mode(DIRECTORY_PERMISSIONS))
    }

    #[cfg(target_family = "windows")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        todo!()
    }

    #[cfg(target_family = "windows")]
    fn create_directory(&self, path: &Path) -> Result<(), WriteError> {
        todo!()
    }
}

////////////////////////////////////////////////////////////////////////////////////
// TESTS
////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod test {
    use crate::agent_type::definition::AgentType;
    use crate::agent_type::environment::Environment;
    use crate::sub_agent::persister::config_persister::ConfigurationPersister;
    use crate::sub_agent::persister::config_persister_file::{
        DIRECTORY_PERMISSIONS, FILE_PERMISSIONS,
    };
    use crate::super_agent::config::AgentID;
    use crate::super_agent::defaults::GENERATED_FOLDER_NAME;
    use fs::directory_manager::mock::MockDirectoryManagerMock;
    use fs::directory_manager::DirectoryManager;
    use fs::mock::MockLocalFile;
    use fs::writer_file::FileWriter;
    use std::fs::Permissions;
    use std::io::ErrorKind;
    use std::path::{Path, PathBuf};

    use fs::directory_manager::DirectoryManagementError::{
        ErrorCreatingDirectory, ErrorDeletingDirectory,
    };
    #[cfg(target_family = "unix")]
    use std::os::unix::fs::PermissionsExt;

    use super::ConfigurationPersisterFile;

    impl<W, C> ConfigurationPersisterFile<W, C>
    where
        C: DirectoryManager,
        W: FileWriter,
    {
        pub fn with_mocks(
            file_writer: W,
            directory_manager: C,
            generated_conf_path: &Path,
        ) -> Self {
            ConfigurationPersisterFile {
                file_writer,
                directory_manager,
                generated_conf_path: PathBuf::from(generated_conf_path),
            }
        }
    }

    #[test]
    fn test_persist_multiple_single_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type =
            AgentType::build_for_testing(AGENT_TYPE_MULTIPLE_FILES, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_MULTIPLE_FILES);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config1_path = agent_files_path.clone();
        config1_path.push("newrelic-infra-1.yml");
        file_writer.should_write(
            config1_path.as_path(),
            "license_key: 11111111111111111\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config2_path = agent_files_path.clone();
        config2_path.push("newrelic-infra-2.yml");
        file_writer.should_write(
            config2_path.as_path(),
            "license_key: 22222222222222222\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config3_path = agent_files_path.clone();
        config3_path.push("newrelic-infra-3.yml");
        file_writer.should_write(
            config3_path.as_path(),
            "license_key: 33333333333333333\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &filled_variables)
            .is_ok());
    }

    #[test]
    fn test_persist_multiple_single_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type =
            AgentType::build_for_testing(AGENT_TYPE_SINGLE_MAP_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_SINGLE_MAP_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_kafka_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_mysql_path = agent_files_path.clone();
        config_mysql_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_mysql_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_mysql_path.push("mysql.yml");
        file_writer.should_write(
            config_mysql_path.as_path(),
            "mysql: true\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_redis_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &filled_variables)
            .is_ok());
    }

    #[test]
    fn test_persist_multiple_multiple_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type =
            AgentType::build_for_testing(AGENT_TYPE_MULTIPLE_MAP_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_MULTIPLE_MAP_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_redis_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_kafka_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_file_path = agent_files_path.clone();
        config_logging_file_path.push("logging.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_logging_file_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_logging_file_path.push("file");
        file_writer.should_write(
            config_logging_file_path.as_path(),
            "some logging conf\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_systemctl_path = agent_files_path.clone();
        config_logging_systemctl_path.push("logging.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            config_logging_systemctl_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        config_logging_systemctl_path.push("systemctl.yml");
        file_writer.should_write(
            config_logging_systemctl_path.as_path(),
            "systemctl: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert!(persister
            .persist_agent_config(&agent_id, &filled_variables)
            .is_ok());
    }

    #[test]
    fn test_error_deleting_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type = AgentType::build_for_testing(AGENT_TYPE_SINGLE_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_SINGLE_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_not_delete(
            agent_files_path.as_path(),
            ErrorDeletingDirectory("oh now...".to_string()),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let result = persister.persist_agent_config(&agent_id, &filled_variables);
        assert!(result.is_err());
        assert_eq!(
            "directory error: `cannot delete directory: `oh now...``".to_string(),
            result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_error_creating_agent_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type = AgentType::build_for_testing(AGENT_TYPE_SINGLE_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_SINGLE_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_not_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
            ErrorCreatingDirectory(
                agent_files_path.as_path().to_str().unwrap().to_string(),
                "oh now...".to_string(),
            ),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &filled_variables);
        assert!(persist_result.is_err());
        assert_eq!(
            "directory error: `cannot create directory `some/path/some-agent-id` : `oh now...``"
                .to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_error_creating_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type = AgentType::build_for_testing(AGENT_TYPE_SINGLE_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_SINGLE_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_not_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
            ErrorCreatingDirectory(
                agent_files_path.as_path().to_str().unwrap().to_string(),
                "oh now...".to_string(),
            ),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &filled_variables);
        assert!(persist_result.is_err());
        assert_eq!(
            "directory error: `cannot create directory `some/path/some-agent-id` : `oh now...``"
                .to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_file_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type =
            AgentType::build_for_testing(AGENT_TYPE_MULTIPLE_FILES, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_MULTIPLE_FILES);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes gill happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::PermissionDenied);

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id, &filled_variables);
        assert!(persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `permission denied``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_filemap_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockLocalFile::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let agent_type =
            AgentType::build_for_testing(AGENT_TYPE_SINGLE_MAP_FILE, &Environment::OnHost);
        let filled_variables = agent_type.fill_variables(AGENT_VALUES_SINGLE_MAP_FILE);

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(&agent_id);

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            generated_conf_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        let mut integrations_path = agent_files_path.clone();
        integrations_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            integrations_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );
        let mut integrations_path = agent_files_path.clone();
        integrations_path.push("integrations.d");
        // We need to mock create because path will never exist on the test
        directory_manager.should_create(
            integrations_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes will happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::AlreadyExists);

        // Create persister
        let persister = ConfigurationPersisterFile::with_mocks(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist_agent_config(&agent_id.clone(), &filled_variables);
        assert!(persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `entity already exists``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_persister_with_custom_data_dir() {
        let custom_data_dir = PathBuf::from("some/data/dir");
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let persister = ConfigurationPersisterFile::new(custom_data_dir.as_path());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = custom_data_dir;
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id);

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    #[test]
    fn test_persister_with_custom_data_dir_disallow_dots() {
        let custom_data_dir = PathBuf::from("some/../../data/dir");
        let agent_id = AgentID::new("some-agent-id").unwrap();
        let persister = ConfigurationPersisterFile::new(custom_data_dir.as_path());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = custom_data_dir;
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id);

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    //////////////////////////////////////////////////
    // Fixtures
    //////////////////////////////////////////////////

    const AGENT_TYPE_SINGLE_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra.yml
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_FILE: &str = r#"
config_file: |
  license_key: 1234567890987654321
  log:
    level: debug
"#;

    const AGENT_TYPE_MULTIPLE_FILES: &str = r#"

namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file1:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-1.yml
  config_file2:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-2.yml
  config_file3:
    description: "Newrelic infra configuration path"
    type: file
    required: false
    file_path: newrelic-infra-3.yml
    default: |
      license_key: 33333333333333333
      log:
        level: trace
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file1} --config=${config_file2} --config=${config_file3}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_FILES: &str = r#"
config_file1: |
  license_key: 11111111111111111
  log:
    level: info

config_file2: |
  license_key: 22222222222222222
  log:
    level: debug
"#;

    const AGENT_TYPE_SINGLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  mysql.yml: |
    mysql: true
    log:
      level: trace
  kafka.yml: |
    kafka: true
    log:
      level: debug
"#;

    const AGENT_TYPE_MULTIPLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
  logging:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: logging.d
  config3:
    description: "some config map"
    type: map[string]string
    required: true
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations} --logging=${logging}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  kafka.yml: |
    kafka: true
    log:
      level: debug
logging:
  file: |
    some logging conf
  systemctl.yml: |
    systemctl: true
    log:
      level: debug
config3:
  log_level: trace
  forward: "true"
"#;
}
