use std::{collections::HashMap, str::FromStr, sync::Arc};

use kube::{
    api::{ApiResource, DeleteParams, DynamicObject, PostParams, TypeMeta},
    core::GroupVersion,
    discovery::pinned_kind,
    Api, Resource,
};
use tracing::{debug, warn};

use super::{
    client::{delete_collection, get_name},
    error::K8sError,
    reflector::definition::{Reflector, ReflectorBuilder},
};

/// An abstraction of [DynamicObject] that allow performing operations concerning objects known at Runtime either
/// using the k8s API or a [Reflector].
#[derive(Debug)]
pub struct DynamicResource {
    api: Api<DynamicObject>,
    reflector: Reflector<DynamicObject>,
}

/// [DynamicResource] collection. Each resource is accessible through the corresponding [TypeMeta].
#[derive(Debug)]
pub struct DynamicResources(HashMap<TypeMeta, DynamicResource>);

impl DynamicResource {
    pub async fn try_new(
        api_resource: &ApiResource,
        client: kube::Client,
        builder: &ReflectorBuilder,
    ) -> Result<Self, K8sError> {
        Ok(Self {
            api: Api::default_namespaced_with(client, api_resource),
            reflector: builder.try_build_with_api_resource(api_resource).await?,
        })
    }

    /// Looks for a [DynamicObject] by name, using the corresponding reflector.
    pub fn get(&self, name: &str) -> Option<Arc<DynamicObject>> {
        self.reflector.reader().find(|obj| {
            obj.metadata
                .name
                .as_ref()
                .is_some_and(|obj_name| obj_name.eq(name))
        })
    }

    /// Check if the provided object has changed according to the fields the super-agent sets up.
    pub fn has_changed(&self, obj: &DynamicObject) -> Result<bool, K8sError> {
        let name = get_name(obj)?;
        let existing_obj = self.get(name.as_str());
        match existing_obj {
            None => Ok(true), // It does not exist
            Some(obj_old) => {
                // We check only specs and labels since those are the only data we are currently
                // setting up. Moreover, there are many fields autogenerated by k8s controlplane
                // that we need to ignore (es: data.status or metadata.resourceVersion:)
                if obj_old.data["spec"] != obj.data["spec"] {
                    return Ok(true);
                }
                if obj_old.metadata.labels != obj.metadata.labels {
                    return Ok(true);
                }
                Ok(false)
            }
        }
    }

    /// Creates the provided object in the cluster, if an object with the same name exists, it is updated.
    pub async fn apply(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        let name = get_name(obj)?;
        self.api
            .entry(name.as_str())
            .await
            .map_err(|e| {
                K8sError::GetDynamic(format!("getting dynamic object with name {}: {}", name, e))
            })?
            .and_modify(|obj_old| {
                obj_old.data.clone_from(&obj.data);
                // TODO: update comment.
                // We are updating just particular metadata fields, the ones that are supported currently by the config
                // Moreover, if you add a new one you need to consider them in has_dynamic_object_changed
                obj_old.metadata.labels.clone_from(&obj.metadata.labels);
            })
            .or_insert(|| obj.clone())
            .commit(&PostParams::default())
            .await?;
        Ok(())
    }

    pub async fn apply_if_changed(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        if !self.has_changed(obj)? {
            debug!("not applying k8s resource since it has not changed");
            return Ok(());
        }
        debug!(
            "applying k8s object since it has changed: '{:?}'",
            obj.metadata
        );
        self.apply(obj).await
    }

    /// Deletes the [DynamicObject] whose name if provieds, returns an error if it does not exist.
    pub async fn delete(&self, name: &str) -> Result<(), K8sError> {
        match self.api.delete(name, &DeleteParams::default()).await? {
            // List of objects being deleted.
            either::Left(dynamic_object) => {
                debug!("Deleting object: {:?}", dynamic_object.meta().name);
            }
            // Status response of the deleted objects.
            either::Right(status) => {
                debug!("Deleted collection: status={:?}", status);
            }
        }
        Ok(())
    }

    /// Deletes the dynamic objects matching with the provided label selector from the cluster.
    pub async fn delete_by_label_selector(&self, label_selector: &str) -> Result<(), K8sError> {
        delete_collection(&self.api, label_selector).await
    }
}

impl DynamicResources {
    pub async fn try_new(
        dynamic_types: impl IntoIterator<Item = TypeMeta>,
        client: &kube::Client,
        builder: &ReflectorBuilder,
    ) -> Result<Self, K8sError> {
        let mut inner = HashMap::new();

        for type_meta in dynamic_types.into_iter() {
            let gvk = &GroupVersion::from_str(type_meta.api_version.as_str())?
                .with_kind(type_meta.kind.as_str());

            let api_resource = match pinned_kind(client, gvk).await {
                Ok((api_resource, _)) => api_resource,
                Err(err) => {
                    warn!(
                        "The gvk '{:?}' was not found in the cluster and cannot be used: {}",
                        gvk, err
                    );
                    continue;
                }
            };

            inner.insert(
                type_meta,
                DynamicResource::try_new(&api_resource, client.to_owned(), builder).await?,
            );
        }
        Ok(Self(inner))
    }

    pub fn supported_dynamic_type_metas(&self) -> Vec<TypeMeta> {
        self.0.keys().cloned().collect()
    }

    pub fn try_get(&self, type_meta: &TypeMeta) -> Result<&DynamicResource, K8sError> {
        let ds = self.0.get(type_meta).ok_or_else(|| {
            K8sError::UnexpectedKind(format!("no reflector for type {:?}", type_meta))
        })?;
        Ok(ds)
    }
}

#[cfg(test)]
mod test {

    use assert_matches::assert_matches;

    use super::*;

    #[test]
    fn test_error_on_missing_resource_definition() {
        let dynamics = DynamicResources(HashMap::default());
        let type_meta = TypeMeta {
            api_version: "newrelic.com/v1".to_string(),
            kind: "Foo".to_string(),
        };
        let err = dynamics.try_get(&type_meta).unwrap_err();
        assert_matches!(err, K8sError::UnexpectedKind(_))
    }
}
