//! This module holds helpers and to perform k8s operations with resources whose type is known at runtime
//! (DynamicObjects).
use super::{
    client::{get_name, get_type_meta},
    error::K8sError,
    reflector::definition::{Reflector, ReflectorBuilder},
    utils::display_type,
};
use kube::{
    api::{DeleteParams, DynamicObject, PostParams, TypeMeta},
    core::GroupVersion,
    discovery::pinned_kind,
    Api, Resource,
};
use std::{collections::HashMap, str::FromStr, sync::Arc};
use tracing::debug;

/// An abstraction of [DynamicObject] that allow performing operations concerning objects known at Runtime either
/// using the k8s API or a [Reflector].
#[derive(Debug)]
pub struct DynamicObjectManager {
    api: Api<DynamicObject>,
    reflector: Reflector<DynamicObject>,
}

impl DynamicObjectManager {
    pub async fn try_new(
        type_meta: &TypeMeta,
        client: kube::Client,
        builder: &ReflectorBuilder,
    ) -> Result<Self, K8sError> {
        let gvk = &GroupVersion::from_str(type_meta.api_version.as_str())?
            .with_kind(type_meta.kind.as_str());
        let (api_resource, _) = pinned_kind(&client, gvk)
            .await
            .map_err(|_| K8sError::MissingAPIResource(display_type(type_meta)))?;

        Ok(Self {
            api: Api::default_namespaced_with(client, &api_resource),
            reflector: builder.try_build_with_api_resource(&api_resource).await?,
        })
    }

    /// Looks for a [DynamicObject] by name, using the corresponding reflector.
    pub fn get(&self, name: &str) -> Option<Arc<DynamicObject>> {
        self.reflector
            .reader()
            .find(|obj| obj.metadata.name.as_deref() == Some(name))
    }

    /// Returns the list of [DynamicObject].
    pub fn list(&self) -> Vec<Arc<DynamicObject>> {
        self.reflector.reader().state()
    }

    /// Check if the provided object has changed according to the fields the super-agent sets up.
    pub fn has_changed(&self, obj: &DynamicObject) -> Result<bool, K8sError> {
        let name = get_name(obj)?;
        let existing_obj = self.get(name.as_str());
        match existing_obj {
            None => Ok(true), // It does not exist
            Some(obj_old) => {
                // We check only specs, annotations and labels since those are the only data we are currently
                // setting up. Moreover, there are many fields autogenerated by k8s controlplane
                // that we need to ignore (es: data.status or metadata.resourceVersion:)
                if obj_old.data["spec"] != obj.data["spec"] {
                    return Ok(true);
                }
                if obj_old.metadata.labels != obj.metadata.labels {
                    return Ok(true);
                }
                if obj_old.metadata.annotations != obj.metadata.annotations {
                    return Ok(true);
                }
                Ok(false)
            }
        }
    }

    /// Creates the provided object in the cluster, if an object with the same name exists, it is updated.
    pub async fn apply(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        let name = get_name(obj)?;
        self.api
            .entry(name.as_str())
            .await
            .map_err(|e| {
                K8sError::GetDynamic(format!("getting dynamic object with name {}: {}", name, e))
            })?
            .and_modify(|obj_old| {
                obj_old.data.clone_from(&obj.data);
                // We are updating just particular metadata fields, the ones that are supported currently by the config.
                // Moreover, if you add a new one you need to consider them in in the `has_changed` method.
                obj_old.metadata.labels.clone_from(&obj.metadata.labels);
                obj_old
                    .metadata
                    .annotations
                    .clone_from(&obj.metadata.annotations);
            })
            .or_insert(|| obj.clone())
            .commit(&PostParams::default())
            .await?;
        Ok(())
    }

    pub async fn apply_if_changed(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        if !self.has_changed(obj)? {
            debug!("not applying k8s resource since it has not changed");
            return Ok(());
        }
        debug!(
            "applying k8s object since it has changed: '{:?}'",
            obj.metadata
        );
        self.apply(obj).await
    }

    /// Deletes the [DynamicObject] whose name if provieds, returns an error if it does not exist.
    pub async fn delete(&self, name: &str) -> Result<(), K8sError> {
        match self.api.delete(name, &DeleteParams::default()).await? {
            // List of objects being deleted.
            either::Left(dynamic_object) => {
                debug!("Deleting object: {:?}", dynamic_object.meta().name);
            }
            // Status response of the deleted objects.
            either::Right(status) => {
                debug!("Deleted collection: status={:?}", status);
            }
        }
        Ok(())
    }
}

/// Holds a collection of [DynamicObjectManager] by [TypeMeta] to perform operations with objects known at runtime.
/// [DynamicObjectManager] are initialized lazily when a method is called.
/// [K8sError::MissingAPIResource] is returned if the manager init failure reason is that there is no such API Resource in the cluster.
pub struct DynamicObjectManagers {
    client: kube::Client,
    manager_by_type: tokio::sync::Mutex<HashMap<TypeMeta, DynamicObjectManager>>,
    reflector_builder: ReflectorBuilder,
}

impl DynamicObjectManagers {
    pub fn new(client: kube::Client, reflector_builder: ReflectorBuilder) -> Self {
        Self {
            client,
            manager_by_type: tokio::sync::Mutex::new(HashMap::default()),
            reflector_builder,
        }
    }

    pub async fn get(
        &self,
        type_meta: &TypeMeta,
        name: &str,
    ) -> Result<Option<Arc<DynamicObject>>, K8sError> {
        Ok(self
            .lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .get(name))
    }
    pub async fn delete(&self, type_meta: &TypeMeta, name: &str) -> Result<(), K8sError> {
        self.lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .delete(name)
            .await
    }
    pub async fn list(&self, type_meta: &TypeMeta) -> Result<Vec<Arc<DynamicObject>>, K8sError> {
        Ok(self
            .lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .list())
    }

    pub async fn apply(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        let type_meta = &get_type_meta(obj)?;

        self.lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .apply(obj)
            .await
    }

    pub async fn apply_if_changed(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        let type_meta = &get_type_meta(obj)?;

        self.lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .apply_if_changed(obj)
            .await
    }

    pub async fn has_changed(&self, obj: &DynamicObject) -> Result<bool, K8sError> {
        let type_meta = &get_type_meta(obj)?;

        self.lock_update_managers(type_meta)
            .await?
            .get(type_meta)
            .ok_or(K8sError::MissingInitializedManager(display_type(type_meta)))?
            .has_changed(obj)
    }

    /// Verifies if the manager for the provided [TypeMeta], if it does not exist it creates it, and returns
    /// the mutex guard to the locked manager_by_type.
    async fn lock_update_managers(
        &self,
        type_meta: &TypeMeta,
    ) -> Result<tokio::sync::MutexGuard<'_, HashMap<TypeMeta, DynamicObjectManager>>, K8sError>
    {
        // Check if the manager is already initialized.
        let managers_guard = self.manager_by_type.lock().await;
        if managers_guard.get(type_meta).is_some() {
            return Ok(managers_guard);
        }
        drop(managers_guard);

        debug!(
            "Initializing dynamic object manager for type: {:?}",
            type_meta
        );

        let dynamic_object_manager =
            DynamicObjectManager::try_new(type_meta, self.client.clone(), &self.reflector_builder)
                .await?;

        let mut managers_guard = self.manager_by_type.lock().await;
        managers_guard.insert(type_meta.clone(), dynamic_object_manager);

        Ok(managers_guard)
    }
}
