//! This module holds helpers and to perform k8s operations with resources whose type is known at runtime
//! (DynamicObjects).
use super::{
    client::{delete_collection, get_name},
    error::K8sError,
    reflector::definition::{Reflector, ReflectorBuilder},
    utils::display_type,
};
use base64::engine::general_purpose::STANDARD;
use either::Either;
use kube::api::{ObjectList, Patch, PatchParams};
use kube::client::Status;
use kube::{
    Api, Error, Resource,
    api::{DeleteParams, DynamicObject, PostParams, TypeMeta},
    core::GroupVersion,
    discovery::pinned_kind,
};
use std::{collections::HashMap, str::FromStr, sync::Arc};
use tokio::sync::Mutex;
use tracing::debug;

/// An abstraction of [DynamicObject] that allow performing operations concerning objects known at Runtime either
/// using the k8s API or a [Reflector].
#[derive(Debug)]
pub struct DynamicObjectManager {
    api: Api<DynamicObject>,
    reflector: Reflector<DynamicObject>,
}

impl DynamicObjectManager {
    pub async fn try_new(
        type_meta: &TypeMeta,
        client: kube::Client,
        builder: &ReflectorBuilder,
    ) -> Result<Self, K8sError> {
        let gvk = &GroupVersion::from_str(type_meta.api_version.as_str())?
            .with_kind(type_meta.kind.as_str());
        let (api_resource, _) = pinned_kind(&client, gvk)
            .await
            .map_err(|_| K8sError::MissingAPIResource(display_type(type_meta)))?;

        Ok(Self {
            api: Api::default_namespaced_with(client, &api_resource),
            reflector: builder.try_build_with_api_resource(&api_resource).await?,
        })
    }

    /// Looks for a [DynamicObject] by name, using the corresponding reflector.
    pub fn get(&self, name: &str) -> Option<Arc<DynamicObject>> {
        self.reflector
            .reader()
            .find(|obj| obj.metadata.name.as_deref() == Some(name))
    }

    /// Returns the list of [DynamicObject].
    pub fn list(&self) -> Vec<Arc<DynamicObject>> {
        self.reflector.reader().state()
    }

    /// Check if the provided object has changed according to the fields the agent-control sets up.
    pub fn has_changed(&self, obj: &DynamicObject) -> Result<bool, K8sError> {
        let name = get_name(obj)?;
        let existing_obj = self.get(name.as_str());
        match existing_obj {
            None => Ok(true), // It does not exist
            Some(obj_old) => {
                // We check only content, annotations and labels since those are the only data we are currently
                // setting up. Moreover, there are many fields autogenerated by k8s controlPlane
                // that we need to ignore (es: data.status or metadata.resourceVersion:)
                if !object_contents_are_equal(obj, &obj_old) {
                    return Ok(true);
                }
                if obj_old.metadata.labels != obj.metadata.labels {
                    return Ok(true);
                }
                if obj_old.metadata.annotations != obj.metadata.annotations {
                    return Ok(true);
                }
                Ok(false)
            }
        }
    }

    /// Creates the provided object in the cluster, if an object with the same name exists, it is updated.
    pub async fn apply(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        let name = get_name(obj)?;
        self.api
            .entry(name.as_str())
            .await
            .map_err(|e| {
                K8sError::GetDynamic(format!("getting dynamic object with name {}: {}", name, e))
            })?
            .and_modify(|obj_old| {
                obj_old.data.clone_from(&obj.data);
                // We are updating just particular metadata fields, the ones that are supported currently by the config.
                // Moreover, if you add a new one you need to consider them in the `has_changed` method.
                obj_old.metadata.labels.clone_from(&obj.metadata.labels);
                obj_old
                    .metadata
                    .annotations
                    .clone_from(&obj.metadata.annotations);
            })
            .or_insert(|| obj.clone())
            .commit(&PostParams::default())
            .await?;
        Ok(())
    }

    pub async fn apply_if_changed(&self, obj: &DynamicObject) -> Result<(), K8sError> {
        if !self.has_changed(obj)? {
            debug!("not applying k8s resource since it has not changed");
            return Ok(());
        }
        debug!(
            "applying k8s object since it has changed: '{:?}' '{:?}'",
            obj.types, obj.metadata,
        );
        self.apply(obj).await
    }

    pub async fn patch(
        &self,
        name: &str,
        patch: serde_json::Value,
    ) -> Result<DynamicObject, K8sError> {
        self.api
            .patch(name, &PatchParams::default(), &Patch::Merge(patch))
            .await
            .map_err(|error| K8sError::PatchError(name.to_string(), error.to_string()))
    }

    /// Deletes the [DynamicObject], returns an ok if it does not exist.
    pub async fn delete(&self, name: &str) -> Result<Either<DynamicObject, Status>, K8sError> {
        let result = self.api.delete(name, &DeleteParams::default()).await;

        if let Err(Error::Api(api)) = result.as_ref() {
            if api.clone().code == 404 {
                return Ok(Either::Right(Status::success()));
            }
        }

        let either = result?;

        match either.clone() {
            // List of objects being deleted.
            either::Left(dynamic_object) => {
                debug!("Deleting object: {:?}", dynamic_object.meta().name);
            }
            // Status response of the deleted objects.
            either::Right(status) => {
                debug!("Deleted collection: status={:?}", status);
            }
        }
        Ok(either)
    }

    pub async fn delete_collection(
        &self,
        label_selector: &str,
    ) -> Result<Either<ObjectList<DynamicObject>, Status>, K8sError> {
        delete_collection(&self.api, label_selector).await
    }
}

/// Holds a collection of [DynamicObjectManager] by [TypeMeta] to perform operations with objects known at runtime.
/// [DynamicObjectManager] are initialized lazily when a method is called.
/// [K8sError::MissingAPIResource] is returned if the manager init failure reason is that there is no such API Resource in the cluster.
pub struct DynamicObjectManagers {
    client: kube::Client,
    manager_by_type: Mutex<HashMap<TypeMeta, Arc<DynamicObjectManager>>>,
    reflector_builder: ReflectorBuilder,
}

impl DynamicObjectManagers {
    pub fn new(client: kube::Client, reflector_builder: ReflectorBuilder) -> Self {
        Self {
            client,
            manager_by_type: Mutex::new(HashMap::default()),
            reflector_builder,
        }
    }

    /// Obtains the manager for the provided [TypeMeta]. If it does not exist it creates it and stores it.
    pub async fn get_or_create_manager(
        &self,
        type_meta: &TypeMeta,
    ) -> Result<Arc<DynamicObjectManager>, K8sError> {
        // Return the manager if it is already initialized
        let mut managers_guard = self.manager_by_type.lock().await;
        if let Some(manager) = managers_guard.get(type_meta) {
            if manager.reflector.is_running() {
                return Ok(manager.clone());
            }
            // Remove the manager and reinitialized.
            managers_guard.remove(type_meta);
        }
        drop(managers_guard);

        // Create and store it otherwise
        debug!(
            "Initializing dynamic object manager for type: {:?}",
            type_meta
        );

        let dynamic_object_manager =
            DynamicObjectManager::try_new(type_meta, self.client.clone(), &self.reflector_builder)
                .await?;

        let mut managers_guard = self.manager_by_type.lock().await;
        let manager = Arc::new(dynamic_object_manager);
        managers_guard.insert(type_meta.clone(), manager.clone());

        Ok(manager)
    }
}

/// Checks if the content of two dynamic objects are considered equal. The order matters since the
/// object `from_manifest` can be different from the object `from_cluster` and still have equivalent
/// content. Metadata is not considered.
///
/// # Arguments
///
/// * `from_manifest` - DynamicObject representing manifest that can be applied to the cluster.
/// * `from_cluster` - DynamicObject representing an object read from the cluster.
fn object_contents_are_equal(from_manifest: &DynamicObject, from_cluster: &DynamicObject) -> bool {
    // Compare Secrets data
    if from_manifest
        .types
        .as_ref()
        .is_some_and(|t| t.api_version == "v1" && t.kind == "Secret")
    {
        return secrets_data_are_equal(from_manifest, from_cluster);
    }
    // Compare any other object
    // TODO: consider support for particular objects only and validate object type meta when agent-types are defined.
    from_manifest.data["spec"] == from_cluster.data["spec"]
}

/// This function checks if the data of the two DynamicObjects with underlying secrets are the same.
/// To do so, merges (after encoding) the data from `stringData` and `data` fields.
/// Note: the base64 encoding of the `stringData` is the same as in [k8s_openapi::ByteString].
///
/// # Arguments
///
/// * `from_manifest` - DynamicObject representing a Secret manifest which may contain data and/or stringData.
/// * `from_cluster` - DynamicObject representing a secret read from the cluster which can only contain secret data in
///   the data field as string_data is a write-only field.
fn secrets_data_are_equal(from_manifest: &DynamicObject, from_cluster: &DynamicObject) -> bool {
    // Secret values from the data field.
    let mut manifest_merged_data = from_manifest.data["data"]
        .as_object()
        .cloned()
        .unwrap_or_default();
    // Secret values from the stringData field (we need to manually encode them to base64)
    if let Some(string_data) = from_manifest.data["stringData"].as_object() {
        // Only strings are expected, see <https://kubernetes.io/docs/concepts/configuration/secret/#restriction-names-data>
        // therefore, any other value is skipped.
        manifest_merged_data.extend(string_data.iter().filter_map(|(k, v)| {
            v.as_str().map(|s| {
                let encoded = base64::Engine::encode(&STANDARD, s);
                (k.to_string(), serde_json::Value::String(encoded))
            })
        }));
    }
    // Compare merged-data from manifest to data from cluster
    match from_cluster.data["data"].as_object() {
        Some(from_cluster_data) => &manifest_merged_data == from_cluster_data,
        None => manifest_merged_data.is_empty(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use kube::api::ObjectMeta;
    use serde_json::json;

    #[test]
    fn test_secrets_data_are_equal() {
        #[derive(Default)]
        struct TestCase {
            name: &'static str,
            equal: bool,
            manifest_string_data: serde_json::Value,
            manifest_data: serde_json::Value,
            cluster_data: serde_json::Value,
        }

        impl TestCase {
            fn run(self) {
                let type_meta = TypeMeta {
                    api_version: "v1".into(),
                    kind: "Secret".into(),
                };
                let from_manifest = DynamicObject {
                    types: Some(type_meta.clone()),
                    metadata: ObjectMeta {
                        name: Some(self.name.to_string()),
                        ..Default::default()
                    },
                    data: json!({"stringData": self.manifest_string_data, "data": self.manifest_data}),
                };
                let from_cluster = DynamicObject {
                    types: Some(type_meta),
                    metadata: ObjectMeta {
                        name: Some(self.name.to_string()),
                        ..Default::default()
                    },
                    data: json!({"data": self.cluster_data}),
                };
                assert_eq!(
                    secrets_data_are_equal(&from_manifest, &from_cluster),
                    self.equal,
                    "Test '{}' failed (expected equal {})\n - From manifest: string_data: {:?}, data: {:?}\n - From cluster: {:?}",
                    self.name,
                    self.equal,
                    self.manifest_string_data,
                    self.manifest_data,
                    self.cluster_data,
                );
            }
        }

        let test_cases = [
            TestCase {
                name: "Empty",
                equal: true,
                ..Default::default()
            },
            TestCase {
                name: "empty - data",
                equal: false,
                cluster_data: json!({"key": "dmFsdWU="}), // "value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "string_data - empty",
                equal: false,
                manifest_string_data: json!({"key": "value"}),
                ..Default::default()
            },
            TestCase {
                name: "data - empty",
                equal: false,
                manifest_data: json!({"key": "dmFsdWU="}), // "value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "both - empty",
                equal: false,
                manifest_string_data: json!({"another key": "another value"}),
                manifest_data: json!({"key": "dmFsdWU="}), // "value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "Not equal: extra key in manifest",
                equal: false,
                manifest_string_data: json!({"different key": "value", "key": "value"}),
                cluster_data: json!({"key": "dmFsdWU="}), // "value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "Not equal: same keys different content",
                equal: false,
                manifest_string_data: json!({"key": "different value"}),
                cluster_data: json!({"key": "dmFsdWU="}), // "value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "Equal: only string data",
                equal: true,
                manifest_string_data: json!({"key": "value", "another key": "another value"}),
                cluster_data: json!({"key": "dmFsdWU=", "another key": "YW5vdGhlciB2YWx1ZQ=="}), // "value" and "another value" base64 encoded
                ..Default::default()
            },
            TestCase {
                name: "Equal: only data",
                equal: true,
                manifest_data: json!({"key": "dmFsdWU=", "another key": "YW5vdGhlciB2YWx1ZQ=="}), // "value" and "another value" base64 encoded
                cluster_data: json!({"key": "dmFsdWU=", "another key": "YW5vdGhlciB2YWx1ZQ=="}),
                ..Default::default()
            },
            TestCase {
                name: "Equal: combination",
                equal: true,
                manifest_data: json!({"key": "dmFsdWU="}),
                manifest_string_data: json!({"another key": "another value"}),
                cluster_data: json!({"key": "dmFsdWU=", "another key": "YW5vdGhlciB2YWx1ZQ=="}), // "value" and "another value" base64 encoded
            },
        ];

        test_cases.into_iter().for_each(|tc| tc.run());
    }
}
