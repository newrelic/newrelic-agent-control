use std::fs::Permissions;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use crate::config::agent_configs::AgentID;
use crate::config::agent_type::{Agent as AgentType, TrivialValue, VariableType};
use crate::config::persister::config_persister::{ConfigurationPersister, PersistError};
use crate::config::persister::config_writer_file::{WriteError, Writer, WriterFile};
use crate::config::persister::directory_manager::{
    DirectoryManagementError, DirectoryManager, DirectoryManagerFs,
};

const GENERATED_FOLDER_NAME: &str = "auto-generated";
#[cfg(target_family = "unix")]
const FILE_PERMISSIONS: u32 = 0o600;
#[cfg(target_family = "unix")]
const DIRECTORY_PERMISSIONS: u32 = 0o700;

pub struct ConfigurationPersisterFile<W = WriterFile, C = DirectoryManagerFs>
where
    W: Writer,
    C: DirectoryManager,
{
    file_writer: W,
    directory_manager: C,
    generated_conf_path: String,
}

impl ConfigurationPersisterFile<WriterFile, DirectoryManagerFs> {
    // PersisterFile with defaults writer and directory manager
    // and custom data_dir path
    pub fn with_data_dir(data_dir: String) -> Self {
        let mut generated_conf_dir = PathBuf::from(data_dir);
        generated_conf_dir.push(GENERATED_FOLDER_NAME);
        // ensure the generated folder exists
        ConfigurationPersisterFile {
            file_writer: WriterFile::default(),
            directory_manager: DirectoryManagerFs::default(),
            generated_conf_path: generated_conf_dir.as_path().to_str().unwrap().to_string(),
        }
    }
}

impl<W, C> ConfigurationPersister for ConfigurationPersisterFile<W, C>
where
    W: Writer,
    C: DirectoryManager,
{
    fn persist(&self, agent_id: &AgentID, agent_type: &AgentType) -> Result<(), PersistError> {
        let dest_path = self.autogenerated_path(agent_id);
        // Clean the existing autogenerated configuration
        self.directory_manager.delete(dest_path.as_path())?;
        // Create path for agent
        self.create_directory(dest_path.as_path())?;
        // iterate all fields in agent type and persist file ones
        let writing_result: Result<(), WriteError> = agent_type
            .get_variables()
            .iter()
            .try_for_each(|(_fqn, end_spec)| {
                self.write_file_values_to_file(
                    dest_path.as_path(),
                    &end_spec.type_,
                    &end_spec.final_value,
                )
            });

        Ok(writing_result?)
    }

    fn clean(&self, agent_id: &AgentID, _agent_type: &AgentType) -> Result<(), PersistError> {
        let dest_path = self.autogenerated_path(agent_id);
        Ok(self.directory_manager.delete(dest_path.as_path())?)
    }
}

impl<W, C> ConfigurationPersisterFile<W, C>
where
    W: Writer,
    C: DirectoryManager,
{
    // return the full path for autogenerated data for an Agent
    pub(crate) fn autogenerated_path(&self, agent_id: &AgentID) -> PathBuf {
        let mut path = PathBuf::from(&self.generated_conf_path);
        path.push(agent_id.get());
        path
    }

    // Write Agent Values Files to files
    // if variable type is File             -> persist to file
    // if variable type is MapStringFile    -> iterate all elements and persist to files
    // any writing error will stop execution and propagate the error
    fn write_file_values_to_file(
        &self,
        dest_path: &Path,
        variable_type: &VariableType,
        final_value: &Option<TrivialValue>,
    ) -> Result<(), WriteError> {
        match (&variable_type, &final_value) {
            (VariableType::File, Some(TrivialValue::File(file_path_with_content))) => {
                // append file name to destination path and write the contents
                let mut file_dest_path = PathBuf::from(dest_path);
                file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                self.write(
                    file_dest_path.as_path(),
                    file_path_with_content.content.as_str(),
                )
            }
            (VariableType::MapStringFile, Some(TrivialValue::Map(files))) => {
                // iterate all the files inside the map, append them the folder name, append them the file name
                files.iter().try_for_each(|(filename, value)| {
                    match value {
                        TrivialValue::File(file_path_with_content) => {
                            let mut file_dest_path = PathBuf::from(dest_path);
                            file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                            file_dest_path.push(filename);
                            self.write(
                                file_dest_path.as_path(),
                                file_path_with_content.content.as_str(),
                            )?
                        }
                        _ => {
                            unreachable!(
                                "there should not be a map[string]file which content is not a file"
                            );
                        }
                    }
                    Ok(())
                })
            }
            _ => Ok(()), // Not a file
        }
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        self.file_writer.write(
            path,
            content.to_string(),
            Permissions::from_mode(FILE_PERMISSIONS),
        )
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn create_directory(&self, path: &Path) -> Result<(), DirectoryManagementError> {
        self.directory_manager
            .create(path, Permissions::from_mode(DIRECTORY_PERMISSIONS))
    }

    #[cfg(target_family = "windows")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        todo!()
    }

    #[cfg(target_family = "windows")]
    fn create_directory(&self, path: &Path) -> Result<(), WriteError> {
        todo!()
    }
}

////////////////////////////////////////////////////////////////////////////////////
// TESTS
////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod test {
    use crate::config::agent_configs::AgentID;
    use crate::config::agent_type::Agent as AgentType;
    use crate::config::persister::config_persister::ConfigurationPersister;
    use crate::config::persister::config_persister_file::{
        ConfigurationPersisterFile, DIRECTORY_PERMISSIONS, FILE_PERMISSIONS, GENERATED_FOLDER_NAME,
    };
    use crate::config::persister::config_writer_file::test::MockFileWriterMock;
    use crate::config::persister::config_writer_file::{Writer, WriterFile};
    use crate::config::persister::directory_manager::test::MockDirectoryManagerMock;
    use crate::config::persister::directory_manager::{DirectoryManager, DirectoryManagerFs};
    use crate::config::supervisor_config::SupervisorConfig;
    use std::fs;
    use std::fs::Permissions;
    use std::io::ErrorKind;
    use std::path::{Path, PathBuf};

    use crate::config::persister::directory_manager::DirectoryManagementError::{
        ErrorCreatingDirectory, ErrorDeletingDirectory,
    };
    #[cfg(target_family = "unix")]
    use std::os::unix::fs::PermissionsExt;

    impl<W, C> ConfigurationPersisterFile<W, C>
    where
        W: Writer,
        C: DirectoryManager,
    {
        pub fn new(file_writer: W, directory_manager: C, generated_conf_path: &Path) -> Self {
            ConfigurationPersisterFile {
                file_writer,
                directory_manager,
                generated_conf_path: generated_conf_path.to_str().unwrap().to_string(),
            }
        }
    }

    #[test]
    // This test is the only one that writes to an actual file in the FS
    fn test_configuration_persister_single_file() {
        let tempdir = tempfile::tempdir().unwrap();
        let mut temp_path = PathBuf::from(&tempdir.path());
        temp_path.push("test_configuration_persister_single_file");

        let dir_manager = DirectoryManagerFs::default();
        let res = dir_manager.create(temp_path.as_path(), Permissions::from_mode(0o700));

        assert_eq!(true, res.is_ok());
        let persister = ConfigurationPersisterFile::new(
            WriterFile::default(),
            DirectoryManagerFs::default(),
            temp_path.as_path(),
        );
        let agent_id = AgentID::new("SomeAgentID".to_string());

        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();
        agent_type = agent_type.populate(agent_values).unwrap();

        assert_eq!(
            true,
            persister.persist(&agent_id.clone(), &agent_type).is_ok()
        );
        temp_path.push(agent_id.get());
        temp_path.push("newrelic-infra.yml");
        assert_eq!(
            EXPECTED_CONTENT_SINGLE_FILE,
            fs::read_to_string(temp_path.as_path()).unwrap()
        );
    }

    #[test]
    fn test_persist_multiple_single_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_FILES.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_FILES.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config1_path = agent_files_path.clone();
        config1_path.push("newrelic-infra-1.yml");
        file_writer.should_write(
            config1_path.as_path(),
            "license_key: 11111111111111111\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config2_path = agent_files_path.clone();
        config2_path.push("newrelic-infra-2.yml");
        file_writer.should_write(
            config2_path.as_path(),
            "license_key: 22222222222222222\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config3_path = agent_files_path.clone();
        config3_path.push("newrelic-infra-3.yml");
        file_writer.should_write(
            config3_path.as_path(),
            "license_key: 33333333333333333\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert_eq!(
            true,
            persister.persist(&agent_id.clone(), &agent_type).is_ok()
        );
    }

    #[test]
    fn test_persist_multiple_single_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_mysql_path = agent_files_path.clone();
        config_mysql_path.push("integrations.d");
        config_mysql_path.push("mysql.yml");
        file_writer.should_write(
            config_mysql_path.as_path(),
            "mysql: true\nlog:\n  level: trace\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert_eq!(
            true,
            persister.persist(&agent_id.clone(), &agent_type).is_ok()
        );
    }

    #[test]
    fn test_persist_multiple_multiple_map_files() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let file_permissions = Permissions::from_mode(FILE_PERMISSIONS);
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        let mut config_redis_path = agent_files_path.clone();
        config_redis_path.push("integrations.d");
        config_redis_path.push("redis.yml");
        file_writer.should_write(
            config_redis_path.as_path(),
            "redis: true\nlog:\n  level: info\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_kafka_path = agent_files_path.clone();
        config_kafka_path.push("integrations.d");
        config_kafka_path.push("kafka.yml");
        file_writer.should_write(
            config_kafka_path.as_path(),
            "kafka: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_file_path = agent_files_path.clone();
        config_logging_file_path.push("logging.d");
        config_logging_file_path.push("file");
        file_writer.should_write(
            config_logging_file_path.as_path(),
            "some logging conf\n".to_string(),
            file_permissions.clone(),
        );

        let mut config_logging_systemctl_path = agent_files_path.clone();
        config_logging_systemctl_path.push("logging.d");
        config_logging_systemctl_path.push("systemctl.yml");
        file_writer.should_write(
            config_logging_systemctl_path.as_path(),
            "systemctl: true\nlog:\n  level: debug\n".to_string(),
            file_permissions.clone(),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        assert_eq!(
            true,
            persister.persist(&agent_id.clone(), &agent_type).is_ok()
        );
    }

    #[test]
    fn test_error_deleting_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_not_delete(
            agent_files_path.as_path(),
            ErrorDeletingDirectory("oh now...".to_string()),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let result = persister.persist(&agent_id.clone(), &agent_type);
        assert_eq!(true, result.is_err());
        assert_eq!(
            "directory error: `cannot delete directory: `oh now...``".to_string(),
            result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_error_creating_directory() {
        let generated_conf_path = PathBuf::from("some/path");
        let file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_not_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
            ErrorCreatingDirectory(
                agent_files_path.as_path().to_str().unwrap().to_string(),
                "oh now...".to_string(),
            ),
        );

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist(&agent_id.clone(), &agent_type);
        assert_eq!(true, persist_result.is_err());
        assert_eq!(
            "directory error: `cannot create directory `some/path/SomeAgentID` : `oh now...``"
                .to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_file_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_MULTIPLE_FILES.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_MULTIPLE_FILES.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes gill happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::PermissionDenied);

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist(&agent_id.clone(), &agent_type);
        assert_eq!(true, persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `permission denied``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_writing_filemap_type_should_stop_processing_the_rest() {
        let generated_conf_path = PathBuf::from("some/path");
        let mut file_writer = MockFileWriterMock::new();
        let mut directory_manager = MockDirectoryManagerMock::new();
        let agent_id = AgentID::new("SomeAgentID".to_string());
        let mut agent_type: AgentType =
            serde_yaml::from_reader(AGENT_TYPE_SINGLE_MAP_FILE.as_bytes()).unwrap();
        let agent_values: SupervisorConfig =
            serde_yaml::from_reader(AGENT_VALUES_SINGLE_MAP_FILE.as_bytes()).unwrap();

        let mut agent_files_path = generated_conf_path.clone();
        agent_files_path.push(agent_id.get().as_str());

        // populate agent type
        agent_type = agent_type.populate(agent_values).unwrap();

        // Expectations
        directory_manager.should_delete(agent_files_path.as_path());
        directory_manager.should_create(
            agent_files_path.as_path(),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        );

        // hashmaps are not ordered, so we cannot assert on what will be written
        // but we can assert how many writes gill happen
        file_writer.should_write_any(1);
        file_writer.should_not_write_any(1, ErrorKind::AlreadyExists);

        // Create persister
        let persister = ConfigurationPersisterFile::new(
            file_writer,
            directory_manager,
            generated_conf_path.as_path(),
        );

        let persist_result = persister.persist(&agent_id.clone(), &agent_type);
        assert_eq!(true, persist_result.is_err());
        assert_eq!(
            "file error: `error creating file: `entity already exists``".to_string(),
            persist_result.err().unwrap().to_string()
        );
    }

    #[test]
    fn test_persister_with_custom_data_dir() {
        let custom_data_dir = "some/data/dir";
        let agent_id = AgentID("some_agent_id".to_string());
        let persister = ConfigurationPersisterFile::with_data_dir(custom_data_dir.to_string());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = PathBuf::from(custom_data_dir);
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id.get());

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    #[test]
    fn test_persister_with_custom_data_dir_disallow_dots() {
        let custom_data_dir = "some/../../data/dir";
        let agent_id = AgentID("some_agent_id".to_string());
        let persister = ConfigurationPersisterFile::with_data_dir(custom_data_dir.to_string());
        let autogenerated_path = persister.autogenerated_path(&agent_id);
        let mut expected_path = PathBuf::from(custom_data_dir);
        expected_path.push(GENERATED_FOLDER_NAME);
        expected_path.push(agent_id.get());

        assert_eq!(expected_path.as_path(), autogenerated_path.as_path());
    }

    //////////////////////////////////////////////////
    // Fixtures
    //////////////////////////////////////////////////

    const AGENT_TYPE_SINGLE_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra.yml
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_FILE: &str = r#"
config_file: |
  license_key: 1234567890987654321
  log:
    level: debug
"#;

    const EXPECTED_CONTENT_SINGLE_FILE: &str = r#"license_key: 1234567890987654321
log:
  level: debug
"#;

    const AGENT_TYPE_MULTIPLE_FILES: &str = r#"

namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  config_file1:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-1.yml
  config_file2:
    description: "Newrelic infra configuration path"
    type: file
    required: true
    file_path: newrelic-infra-2.yml
  config_file3:
    description: "Newrelic infra configuration path"
    type: file
    required: false
    file_path: newrelic-infra-3.yml
    default: |
      license_key: 33333333333333333
      log:
        level: trace
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${config_file1} --config=${config_file2} --config=${config_file3}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_FILES: &str = r#"
config_file1: |
  license_key: 11111111111111111
  log:
    level: info

config_file2: |
  license_key: 22222222222222222
  log:
    level: debug
"#;

    const AGENT_TYPE_SINGLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_SINGLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  mysql.yml: |
    mysql: true
    log:
      level: trace
  kafka.yml: |
    kafka: true
    log:
      level: debug
"#;

    const AGENT_TYPE_MULTIPLE_MAP_FILE: &str = r#"
namespace: newrelic
name: com.newrelic.infrastructure_agent
version: 0.0.1
variables:
  integrations:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: integrations.d
  logging:
    description: "Newrelic infra configuration path"
    type: map[string]file
    required: true
    file_path: logging.d
  config3:
    description: "some config map"
    type: map[string]string
    required: true
deployment:
  on_host:
    executables:
      - path: /usr/bin/newrelic-infra
        args: "--config=${integrations} --logging=${logging}"
    restart_policy:
      backoff_strategy:
        type: fixed
        backoff_delay_seconds: 5
"#;

    const AGENT_VALUES_MULTIPLE_MAP_FILE: &str = r#"
integrations:
  redis.yml: |
    redis: true
    log:
      level: info
  kafka.yml: |
    kafka: true
    log:
      level: debug
logging:
  file: |
    some logging conf
  systemctl.yml: |
    systemctl: true
    log:
      level: debug
config3:
  log_level: trace
  forward: "true"
"#;
}
