use std::fs::Permissions;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use crate::config::agent_configs::AgentID;
use crate::config::agent_type::agent_types::{FinalAgent, VariableType};
use crate::config::agent_type::trivial_value::TrivialValue;
use crate::config::persister::config_persister::{ConfigurationPersister, PersistError};
use crate::config::persister::config_writer_file::{WriteError, Writer, WriterFile};
use crate::config::persister::directory_manager::{
    DirectoryManagementError, DirectoryManager, DirectoryManagerFs,
};

pub struct HashPersisterFile<W = WriterFile>
where
    W: Writer,
{
    file_writer: W,
    directory_manager: C,
    generated_conf_path: String,
}

impl HashPersisterFile<WriterFile, DirectoryManagerFs> {
    // PersisterFile with defaults writer and directory manager
    // and custom data_dir path
    pub fn new(data_dir: String) -> Self {
        let mut generated_conf_dir = PathBuf::from(data_dir);
        generated_conf_dir.push(GENERATED_FOLDER_NAME);

        ConfigurationPersisterFile {
            file_writer: WriterFile::default(),
            directory_manager: DirectoryManagerFs::default(),
            generated_conf_path: generated_conf_dir.as_path().to_str().unwrap().to_string(),
        }
    }
}

impl<W, C> ConfigurationPersister for ConfigurationPersisterFile<W, C>
where
    W: Writer,
    C: DirectoryManager,
{
    fn persist(&self, agent_id: &AgentID, agent_type: &FinalAgent) -> Result<(), PersistError> {
        // Clean the existing autogenerated configuration
        let autogenerated_path = Path::new(&self.generated_conf_path);
        self.directory_manager.delete(autogenerated_path)?;

        // Ensure the autogenerated path exists
        self.directory_manager.create(
            Path::new(&self.generated_conf_path),
            Permissions::from_mode(DIRECTORY_PERMISSIONS),
        )?;

        // Create path for agent
        let dest_path = self.autogenerated_path(agent_id);
        self.create_directory(dest_path.as_path())?;

        // iterate all fields in agent type and persist file ones
        let writing_result: Result<(), WriteError> = agent_type
            .get_variables()
            .iter()
            .try_for_each(|(_fqn, end_spec)| {
                self.write_file_values_to_file(
                    dest_path.as_path(),
                    &end_spec.type_,
                    &end_spec.final_value,
                )
            });

        Ok(writing_result?)
    }

    fn clean(&self, agent_id: &AgentID, _agent_type: &FinalAgent) -> Result<(), PersistError> {
        let dest_path = self.autogenerated_path(agent_id);
        Ok(self.directory_manager.delete(dest_path.as_path())?)
    }
}

impl<W> ConfigurationPersisterFile<W>
where
    W: Writer,
{
    // return the full path for autogenerated data for an Agent
    pub(crate) fn autogenerated_path(&self, agent_id: &AgentID) -> PathBuf {
        let mut path = PathBuf::from(&self.generated_conf_path);
        path.push(agent_id.get());
        path
    }

    // Write Agent Values Files to files
    // if variable type is File             -> persist to file
    // if variable type is MapStringFile    -> iterate all elements and persist to files
    // any writing error will stop execution and propagate the error
    fn write_file_values_to_file(
        &self,
        dest_path: &Path,
        variable_type: &VariableType,
        final_value: &Option<TrivialValue>,
    ) -> Result<(), WriteError> {
        match (&variable_type, &final_value) {
            (VariableType::File, Some(TrivialValue::File(file_path_with_content))) => {
                // append file name to destination path and write the contents
                let mut file_dest_path = PathBuf::from(dest_path);
                file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                self.write(
                    file_dest_path.as_path(),
                    file_path_with_content.content.as_str(),
                )
            }
            (VariableType::MapStringFile, Some(TrivialValue::Map(files))) => {
                // iterate all the files inside the map, append them the folder name, append them the file name
                files.iter().try_for_each(|(filename, value)| {
                    match value {
                        TrivialValue::File(file_path_with_content) => {
                            let mut file_dest_path = PathBuf::from(dest_path);
                            file_dest_path.push(Path::new(file_path_with_content.path.as_str()));
                            file_dest_path.push(filename);
                            self.write(
                                file_dest_path.as_path(),
                                file_path_with_content.content.as_str(),
                            )?
                        }
                        _ => {
                            unreachable!(
                                "there should not be a map[string]file which content is not a file"
                            );
                        }
                    }
                    Ok(())
                })
            }
            _ => Ok(()), // Not a file
        }
    }

    // Wrapper for linux with unix specific permissions
    #[cfg(target_family = "unix")]
    fn write(&self, path: &Path, content: &str) -> Result<(), WriteError> {
        self.file_writer.write(
            path,
            content.to_string(),
            Permissions::from_mode(FILE_PERMISSIONS),
        )
    }
}

