use std::error::Error;

use cfg_if::cfg_if;
use newrelic_super_agent::super_agent::error::AgentError;
use tracing::{error, info};

use newrelic_super_agent::config::persister::config_persister::ConfigurationPersister;
use newrelic_super_agent::config::persister::config_persister_file::ConfigurationPersisterFile;
use newrelic_super_agent::config::store::{SuperAgentConfigStore, SuperAgentConfigStoreFile};
use newrelic_super_agent::opamp::remote_config_hash::HashRepositoryFile;
use newrelic_super_agent::sub_agent::opamp::client_builder::SubAgentOpAMPHttpBuilder;
use newrelic_super_agent::sub_agent::values::remote_values_repository::RemoteValuesRepositoryFile;
use newrelic_super_agent::super_agent::effective_agents_assembler::LocalEffectiveAgentsAssembler;
use newrelic_super_agent::super_agent::instance_id::ULIDInstanceIDGetter;
use newrelic_super_agent::super_agent::opamp::client_builder::SuperAgentOpAMPHttpBuilder;
use newrelic_super_agent::super_agent::super_agent::{SuperAgent, SuperAgentEvent};
use newrelic_super_agent::{cli::Cli, context::Context, logging::Logging};

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // init logging singleton
    Logging::try_init()?;

    let cli = Cli::init_super_agent_cli();

    if cli.print_debug_info() {
        println!("Printing debug info");
        println!("CLI: {:#?}", cli);
        return Ok(());
    }

    info!("Creating the global context");
    let ctx: Context<Option<SuperAgentEvent>> = Context::new();

    info!("Creating the signal handler");
    create_shutdown_signal_handler(ctx.clone())?;

    let mut super_agent_config_storer = SuperAgentConfigStoreFile::new(&cli.get_config_path());

    let opamp_client_builder: Option<SuperAgentOpAMPHttpBuilder> = super_agent_config_storer
        .load()?
        .opamp
        .as_ref()
        .map(|opamp_config| SuperAgentOpAMPHttpBuilder::new(opamp_config.clone()));

    // enable remote config store
    if opamp_client_builder.is_some() {
        super_agent_config_storer = super_agent_config_storer.with_remote()?;
    }

    let instance_id_getter = ULIDInstanceIDGetter::default();

    Ok(run_super_agent(
        super_agent_config_storer,
        ctx,
        opamp_client_builder,
        instance_id_getter,
    )?)
}

fn run_super_agent(
    config_storer: SuperAgentConfigStoreFile,
    ctx: Context<Option<SuperAgentEvent>>,
    opamp_client_builder: Option<SuperAgentOpAMPHttpBuilder>,
    instance_id_getter: ULIDInstanceIDGetter,
) -> Result<(), AgentError> {
    let effective_agents_assembler =
        LocalEffectiveAgentsAssembler::with_remote_management(opamp_client_builder.is_some());
    // TODO: first matching feature will be used if --all-features is specified
    cfg_if! {
     if #[cfg(feature = "onhost")] {
            let hash_repository = HashRepositoryFile::default();
            let sub_agent_hash_repository = HashRepositoryFile::new_sub_agent_repository();
            // Program must run as root if onhost execution
            #[cfg(unix)]
            if !nix::unistd::Uid::effective().is_root() {
                panic!("Program must run as root");
            }
            let sub_agent_opamp : Option<SubAgentOpAMPHttpBuilder> = opamp_client_builder.as_ref().map(Into::into);
           let sub_agent_builder = newrelic_super_agent::sub_agent::on_host::builder::OnHostSubAgentBuilder::new(
                sub_agent_opamp.as_ref(),
                &instance_id_getter,
                &hash_repository,
                &effective_agents_assembler
            );
        } else if #[cfg(feature = "k8s")] {
            //FIXME: this repository should be the concretion needed for K8s, hashRepositoryConfigMap?
            let mut hash_repository = HashRepositoryFile::default();
            let sub_agent_hash_repository = HashRepositoryFile::new_sub_agent_repository();

            let sub_agent_builder = newrelic_super_agent::sub_agent::k8s::builder::K8sSubAgentBuilder::default();
                panic!("K8S still not implemented");
        }
    }

    info!("clean autogenerated folder");
    let config_persister = ConfigurationPersisterFile::default();
    config_persister.delete_all_configs()?;

    info!("Starting the super agent");
    let values_repository = RemoteValuesRepositoryFile::default();

    SuperAgent::new(
        opamp_client_builder.as_ref(),
        &instance_id_getter,
        &hash_repository,
        sub_agent_builder,
        config_storer,
        sub_agent_hash_repository,
        values_repository,
    )
    .run(ctx)
}

fn create_shutdown_signal_handler(
    ctx: Context<Option<SuperAgentEvent>>,
) -> Result<(), ctrlc::Error> {
    ctrlc::set_handler(move || ctx.cancel_all(Some(SuperAgentEvent::Stop)).unwrap()).map_err(
        |e| {
            error!("Could not set signal handler: {}", e);
            e
        },
    )?;

    Ok(())
}
